function solution(p, s) {
  let stack = [];
  while (p.length) {
    p = p.map((el, idx) => el + s[idx]);

    if (p[0] >= 100) {
      let underHundred = p.find((el) => el < 100); // [100, 120, 90]
      if (!underHundred) {
        // [90]
        stack.push(p.length);
        return stack; // [2, 1]
      }

      let idx = p.indexOf(underHundred); // [100, 120, 90]
      stack.push(idx); // [2, 1]
      p = p.slice(idx); // [90]
      s = s.slice(idx); // [5]
    }
  }

  return stack;
}

// [93, 30, 55]	[1, 30, 5]  0
// [94, 60, 60]	[1, 30, 5]  1
// [95, 90, 65]	[1, 30, 5]  2
// [96, 120, 70]	[1, 30, 5]  2
// [97, 120, 70]	[1, 30, 5]  2
// [98, 120, 70]	[1, 30, 5]  2
// [99, 120, 70]	[1, 30, 5]  2
// [100, 120, 90]	[1, 30, 5]  7

// 1번쨰 100 아니면 우선 배포 자체 X

// 1번쨰 100 이고 연달에 있는 애들이 100 이상 같이 배포

// [95, 90, 99, 99, 80, 99]
// [100, 95, 104, 104, 85, 104] => 1개
// [90, 109] => 3개
// [100, 119] => 2개 => find(el < 100) => undefined =>

// 기능 진도 100%일때 서비스 반영
// 기능별 개발속도 모두 다름 => 뒤에있는 개발이 먼저 개발될수 있음 => 배포는 앞에가 100프로 되면 배포가됨
// progresses => 배포 순서도

// stack []
// [93, 30, 55]
// [94, 60, 60]
// [95, 90, 65]
// [96, 120, 70] => 이중에서 100이 넘는 인덱스 + 1를 stack에 저장 [1 + 1], 해당 인덱스까지 자름
// [75]
// ...
// [100] => 이중에서 100이 넘는 인덱스 + 1를 저장 [1 + 1], 해당 인덱스까지 자름(speed)
// [] => length가 0이면 while 종료
// return stack
